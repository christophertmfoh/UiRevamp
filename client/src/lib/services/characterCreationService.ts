import { apiRequest, queryClient } from '@/lib/queryClient';
import type { Character } from '@/lib/types';

interface CharacterGenerationOptions {
  characterType: string;
  role: string;
  customPrompt: string;
  personality: string;
  archetype: string;
}

interface TemplateData {
  name: string;
  description: string;
  category: string;
  traits?: string[];
  background?: string;
  class?: string;
  role?: string;
}

/**
 * Comprehensive character creation service that handles all 4 creation methods
 * with automatic portrait generation
 */
export class CharacterCreationService {
  
  /**
   * Method 1: Custom AI Generation from Free-form Prompt
   * Complete end-to-end flow: Generate ‚Üí Portrait ‚Üí Full Character View
   */
  static async generateFromPrompt(
    projectId: string,
    prompt: string,
    onProgress?: (step: string, progress: number) => void
  ): Promise<Character> {
    console.log('üé≠ Starting AI character generation from prompt');
    console.log('üìù Project ID:', projectId);
    console.log('üìù Prompt length:', prompt.length);
    
    try {
      // Step 1: Generate character data
      onProgress?.('Analyzing your prompt...', 10);
      
      const requestBody = {
        customPrompt: prompt,
        characterType: 'custom',
        role: 'auto-detect',
        personality: 'auto-generate',
        archetype: 'auto-detect'
      };
      
      console.log('üì§ Sending request to:', `/api/projects/${projectId}/characters/generate`);
      console.log('üì§ Request body:', requestBody);
      
      const response = await fetch(`/api/projects/${projectId}/characters/generate`, {
        method: 'POST',
        body: JSON.stringify(requestBody),
        headers: {
          'Content-Type': 'application/json',
        },
      });

      console.log('üì• Response status:', response.status);
      console.log('üì• Response ok:', response.ok);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Server error response:', errorText);
        throw new Error(`Failed to generate character: ${response.status} ${response.statusText} - ${errorText}`);
      }

      onProgress?.('Generating character details...', 40);
      const character = await response.json();
      
      console.log('‚úÖ Character generated with fields:', Object.keys(character).length);
      
      // Step 2: Portrait is already generated by the server, but we can verify/regenerate if needed
      onProgress?.('Finalizing character portrait...', 70);
      
      // The server endpoint already includes portrait generation, so character.imageUrl should exist
      if (character.imageUrl) {
        onProgress?.('Portrait ready...', 90);
        console.log('‚úÖ Portrait included in response:', character.imageUrl.substring(0, 50) + '...');
      } else {
        onProgress?.('Generating portrait...', 75);
        // Fallback: Generate portrait if not already included
        try {
          const portraitResponse = await fetch(`/api/characters/${character.id}/generate-image`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
          });

          if (portraitResponse.ok) {
            const portraitData = await portraitResponse.json();
            character.imageUrl = portraitData.url;
            onProgress?.('Portrait generated successfully...', 90);
            console.log('‚úÖ Fallback portrait generated:', portraitData.url.substring(0, 50) + '...');
          } else {
            console.warn('Portrait generation failed, proceeding without image');
            onProgress?.('Character ready (no portrait)...', 90);
          }
        } catch (portraitError) {
          console.warn('Portrait generation error:', portraitError);
          onProgress?.('Character ready (portrait failed)...', 90);
        }
      }

      onProgress?.('Complete!', 100);
      
      console.log('‚úÖ Character generation complete:', {
        name: character.name,
        hasPortrait: !!character.imageUrl,
        fieldCount: Object.keys(character).length
      });

      return character as Character;
      
    } catch (error) {
      console.error('‚ùå Character generation failed:', error);
      
      // Check if it's a network error (server not running)
      if (error instanceof TypeError && error.message.includes('fetch')) {
        console.error('‚ùå Network error - server may not be running');
        throw new Error('Cannot connect to server. Please make sure the development server is running with "npm run dev".');
      }
      
      throw error;
    }
  }

  /**
   * Method 2: Custom AI Generation with options (legacy method)
   */
  static async generateCustomCharacter(
    projectId: string,
    options: CharacterGenerationOptions
  ): Promise<Partial<Character>> {
    console.log('Creating custom character with automatic portrait');
    
    try {
      const response = await fetch(`/api/projects/${projectId}/characters/generate`, {
        method: 'POST',
        body: JSON.stringify(options),
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        throw new Error('Failed to generate custom character');
      }

      const characterData = await response.json();
      console.log('Custom character generated with portrait:', characterData.imageUrl ? 'Yes' : 'No');
      
      return characterData;
    } catch (error) {
      console.error('Custom character generation failed:', error);
      throw error;
    }
  }

  /**
   * Method 2: Template-based generation with automatic portrait
   */
  static async generateFromTemplate(
    projectId: string,
    templateData: TemplateData
  ): Promise<Partial<Character>> {
    console.log('Creating template character with automatic portrait');
    
    try {
      const response = await fetch(`/api/projects/${projectId}/characters/generate-from-template`, {
        method: 'POST',
        body: JSON.stringify({ templateData }),
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        throw new Error('Failed to generate template character');
      }

      const characterData = await response.json();
      console.log('Template character generated with portrait:', characterData.imageUrl ? 'Yes' : 'No');
      
      return characterData;
    } catch (error) {
      console.error('Template character generation failed:', error);
      throw error;
    }
  }

  /**
   * Method 3: Document import with automatic portrait
   */
  static async importFromDocument(
    projectId: string,
    file: File
  ): Promise<Partial<Character>> {
    console.log('Importing character from document with automatic portrait');
    
    try {
      const formData = new FormData();
      formData.append('document', file);
      formData.append('projectId', projectId);

      const response = await fetch('/api/characters/import-document', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Failed to import character from document');
      }

      const characterData = await response.json();
      console.log('Document character imported with portrait:', characterData.imageUrl ? 'Yes' : 'No');
      
      return characterData;
    } catch (error) {
      console.error('Document import failed:', error);
      throw error;
    }
  }

  /**
   * Method 4: Manual/blank character creation with automatic portrait
   */
  static async createManualCharacter(
    projectId: string,
    characterData: Partial<Character>
  ): Promise<Partial<Character>> {
    console.log('Creating manual character with automatic portrait');
    
    // For manual creation, just return the character data as-is
    // Portrait can be generated separately if needed
    return {
      ...characterData,
      projectId
    };
  }

  /**
   * Saves character to database and invalidates cache
   */
  static async saveCharacter(
    projectId: string,
    characterData: Partial<Character>
  ): Promise<Character> {
    console.log('Saving character to database');
    
    try {
      const response = await fetch('/api/characters', {
        method: 'POST',
        body: JSON.stringify({
          ...characterData,
          projectId,
        }),
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Save character failed with status:', response.status, 'Error:', errorText);
        throw new Error(`Failed to save character: ${response.status} - ${errorText}`);
      }

      const savedCharacter = await response.json();
      
      // Invalidate character cache to refresh the UI
      queryClient.invalidateQueries({ queryKey: ['/api/characters', { projectId }] });
      
      return savedCharacter;
    } catch (error) {
      console.error('Character save failed:', error);
      throw error;
    }
  }

  /**
   * Complete character creation workflow for any method
   */
  static async completeCharacterCreation(
    projectId: string,
    method: 'custom' | 'template' | 'document' | 'manual',
    data: any
  ): Promise<Character> {
    let characterData: Partial<Character>;

    // Generate character with automatic portrait based on method
    switch (method) {
      case 'custom':
        // Custom AI generation already creates character in database, no need to save again
        const customCharacter = await this.generateCustomCharacter(projectId, data);
        // Invalidate cache to refresh UI
        queryClient.invalidateQueries({ queryKey: ['/api/characters', { projectId }] });
        return customCharacter as Character;
      case 'template':
        // Template generation already creates character in database, no need to save again
        const templateCharacter = await this.generateFromTemplate(projectId, data);
        // Invalidate cache to refresh UI
        queryClient.invalidateQueries({ queryKey: ['/api/characters', { projectId }] });
        return templateCharacter as Character;
      case 'document':
        // Document import creates character directly in database, no need to save again
        const importedCharacter = await this.importFromDocument(projectId, data);
        // Invalidate cache to refresh UI
        queryClient.invalidateQueries({ queryKey: ['/api/characters', { projectId }] });
        return importedCharacter as Character;
      case 'manual':
        characterData = await this.createManualCharacter(projectId, data);
        break;
      default:
        throw new Error('Unknown character creation method');
    }

    // Only save manually created characters (others are already saved by their respective endpoints)
    const savedCharacter = await this.saveCharacter(projectId, characterData);
    
    console.log('Character creation complete:', {
      method,
      name: savedCharacter.name,
      hasPortrait: !!savedCharacter.imageUrl,
      portraitCount: savedCharacter.portraits?.length || 0
    });

    return savedCharacter;
  }
}

export default CharacterCreationService;