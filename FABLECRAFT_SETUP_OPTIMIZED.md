# Fablecraft Setup Guide - Optimized Edition

Building Fablecraft with the **Integrated Supabase Stack** - optimized for performance, developer velocity, and scalability.

## Tech Stack

- **Nuxt 3** - Full-stack Vue framework with SSR/SSG capabilities
- **Supabase** - PostgreSQL database with pgvector extension, authentication, and storage
- **Tailwind CSS v3** - Utility-first CSS framework (stable version, not v4 alpha)
- **Pinia** - Official Vue state management
- **Tiptap v2** - Extensible rich text editor
- **Shadcn-vue** - High-quality component library built on Radix Vue
- **Gemini AI** - Initial AI integration using Google's free tier
- **PiAPI** - Future AI expansion for advanced generative capabilities ([piapi.ai](https://piapi.ai/))

## Key Optimizations & Considerations

### pgvector Performance
- ✅ HNSW indexing (superior to IVFFlat for most use cases)
- ✅ Tuned index parameters: `m = 16, ef_construction = 64`
- ✅ Hybrid search combining vector similarity + full-text search
- ✅ 768-dimensional vectors (optimized for Gemini embeddings)

### Server Architecture
- ✅ Nuxt server routes for quick database operations
- ✅ Supabase Edge Functions for AI/long-running tasks
- ✅ Clear separation of concerns for optimal performance

### Version Management
- ✅ Exact version locking with `--save-exact`
- ✅ Tailwind CSS v3 (stable) instead of v4 (alpha)
- ✅ Synchronized Tiptap extension versions
- ✅ `.npmrc` configuration for consistent installs

## Phase 1: Project Foundation

```bash
# Create project directory
mkdir fablecraft-app && cd fablecraft-app

# Initialize Nuxt 3 with latest version
npx nuxi@latest init . --force

# Initialize git repository
git init

# Create version locking configuration
echo "save-exact=true" > .npmrc

# Install core dependencies with exact versions
npm install --save-exact \
  @nuxtjs/supabase@1.4.0 \
  @pinia/nuxt@0.7.0 \
  @vueuse/nuxt@11.3.0

# Install Tiptap with synchronized versions
npm install --save-exact \
  @tiptap/vue-3@2.10.3 \
  @tiptap/pm@2.10.3 \
  @tiptap/starter-kit@2.10.3

# Install UI dependencies
npm install -D --save-exact \
  @nuxtjs/tailwindcss@6.12.2 \
  shadcn-nuxt@0.10.4 \
  radix-vue@1.10.0 \
  class-variance-authority@0.7.1 \
  clsx@2.1.1 \
  tailwind-merge@2.6.0 \
  lucide-vue-next@0.460.0
```

### Create Page Structure

```bash
# Create pages directory structure
mkdir -p pages/project/\[id\]

# Create page files
touch pages/index.vue
touch pages/project/\[id\]/index.vue
touch pages/project/\[id\]/world-bible.vue
touch pages/project/\[id\]/outline.vue
touch pages/project/\[id\]/manuscript.vue
touch pages/project/\[id\]/storyboard.vue
touch pages/project/\[id\]/pre-vis.vue
touch pages/project/\[id\]/scoring.vue
touch pages/project/\[id\]/community.vue
```

## Phase 2: Tailwind CSS v3 Configuration

```bash
# Initialize Tailwind CSS v3 (NOT v4)
npx tailwindcss@3.4.14 init
```

### Configure `tailwind.config.js`:

```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./components/**/*.{js,vue,ts}",
    "./layouts/**/*.vue",
    "./pages/**/*.vue",
    "./plugins/**/*.{js,ts}",
    "./app.vue",
    "./error.vue",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

## Phase 3: Supabase Local Development

```bash
# Install Supabase CLI as dev dependency
npm install -D supabase@1.210.1

# Initialize Supabase in project
npx supabase init

# Start local Supabase instance (requires Docker)
npx supabase start
```

### Create `.env` file:

```bash
# Local Supabase
SUPABASE_URL="http://localhost:54321"
SUPABASE_ANON_KEY="your-local-anon-key-from-supabase-start"
SUPABASE_SERVICE_KEY="your-local-service-key-from-supabase-start"

# AI Configuration
GEMINI_API_KEY="your-gemini-api-key"

# Future AI expansion (PiAPI)
# PIAPI_KEY="your-piapi-key"
# PIAPI_MIDJOURNEY_ENDPOINT="https://api.piapi.ai/midjourney"
# PIAPI_DREAM_MACHINE_ENDPOINT="https://api.piapi.ai/dream-machine"
```

## Phase 4: Optimized Database Schema

Create `supabase/migrations/001_initial_schema.sql`:

```sql
-- Enable pgvector extension for AI embeddings
CREATE EXTENSION IF NOT EXISTS vector WITH SCHEMA extensions;

-- Enable pg_trgm for better text search
CREATE EXTENSION IF NOT EXISTS pg_trgm WITH SCHEMA extensions;

-- User profiles table
CREATE TABLE profiles (
  id UUID REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
  email TEXT UNIQUE,
  full_name TEXT,
  avatar_url TEXT,
  preferences JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Projects table
CREATE TABLE projects (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  settings JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Documents table with vector storage
CREATE TABLE documents (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  project_id BIGINT REFERENCES projects ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  title TEXT NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('MANUSCRIPT', 'WORLD_BIBLE', 'CHARACTER', 'OUTLINE', 'SCENE')),
  content JSONB DEFAULT '{}', -- Tiptap JSON content
  plain_text TEXT, -- Extracted text for search
  word_count INTEGER DEFAULT 0,
  embedding vector(768), -- Gemini embeddings (768 dimensions)
  metadata JSONB DEFAULT '{}',
  version INTEGER DEFAULT 1,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Document versions for history
CREATE TABLE document_versions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  document_id BIGINT REFERENCES documents ON DELETE CASCADE NOT NULL,
  version INTEGER NOT NULL,
  content JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users NOT NULL
);

-- AI generation history
CREATE TABLE ai_generations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  project_id BIGINT REFERENCES projects ON DELETE CASCADE,
  document_id BIGINT REFERENCES documents ON DELETE CASCADE,
  prompt TEXT NOT NULL,
  response TEXT,
  model TEXT NOT NULL,
  tokens_used INTEGER,
  cost DECIMAL(10,4),
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Optimized indexes
-- HNSW index for vector similarity search
CREATE INDEX documents_embedding_idx ON documents 
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- GIN index for full-text search
CREATE INDEX documents_plain_text_idx ON documents 
USING gin (to_tsvector('english', plain_text));

-- Trigram index for fuzzy text search
CREATE INDEX documents_title_trgm_idx ON documents 
USING gin (title gin_trgm_ops);

-- JSONB indexes for metadata queries
CREATE INDEX documents_metadata_idx ON documents 
USING gin (metadata);

-- Composite indexes for common queries
CREATE INDEX documents_project_type_idx ON documents (project_id, type);
CREATE INDEX documents_user_created_idx ON documents (user_id, created_at DESC);

-- Functions and stored procedures
-- Hybrid search function combining vector and text search
CREATE OR REPLACE FUNCTION hybrid_search(
  query_embedding vector(768),
  query_text TEXT,
  search_project_id BIGINT DEFAULT NULL,
  search_type TEXT DEFAULT NULL,
  match_threshold FLOAT DEFAULT 0.7,
  match_count INT DEFAULT 10
)
RETURNS TABLE (
  id BIGINT,
  title TEXT,
  content JSONB,
  type TEXT,
  similarity FLOAT,
  rank FLOAT,
  combined_score FLOAT
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  WITH vector_search AS (
    SELECT 
      d.id,
      d.title,
      d.content,
      d.type,
      1 - (d.embedding <=> query_embedding) AS similarity
    FROM documents d
    WHERE d.embedding IS NOT NULL
    AND (search_project_id IS NULL OR d.project_id = search_project_id)
    AND (search_type IS NULL OR d.type = search_type)
    AND 1 - (d.embedding <=> query_embedding) > match_threshold
    ORDER BY d.embedding <=> query_embedding
    LIMIT match_count * 2
  ),
  text_search AS (
    SELECT 
      d.id,
      ts_rank(to_tsvector('english', d.plain_text), plainto_tsquery('english', query_text)) AS rank
    FROM documents d
    WHERE query_text != ''
    AND (search_project_id IS NULL OR d.project_id = search_project_id)
    AND (search_type IS NULL OR d.type = search_type)
    AND to_tsvector('english', d.plain_text) @@ plainto_tsquery('english', query_text)
    LIMIT match_count * 2
  )
  SELECT 
    COALESCE(v.id, t.id) AS id,
    v.title,
    v.content,
    v.type,
    COALESCE(v.similarity, 0) AS similarity,
    COALESCE(t.rank, 0) AS rank,
    (COALESCE(v.similarity, 0) * 0.7 + COALESCE(t.rank, 0) * 0.3) AS combined_score
  FROM vector_search v
  FULL OUTER JOIN text_search t ON v.id = t.id
  ORDER BY combined_score DESC
  LIMIT match_count;
END;
$$;

-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply triggers
CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON profiles
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_projects_updated_at BEFORE UPDATE ON projects
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_documents_updated_at BEFORE UPDATE ON documents
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- Row Level Security (RLS)
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;
ALTER TABLE document_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_generations ENABLE ROW LEVEL SECURITY;

-- RLS Policies
-- Profiles
CREATE POLICY "Public profiles are viewable by everyone" ON profiles
  FOR SELECT USING (true);

CREATE POLICY "Users can update own profile" ON profiles
  FOR UPDATE USING (auth.uid() = id);

-- Projects
CREATE POLICY "Users can view own projects" ON projects
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can create own projects" ON projects
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own projects" ON projects
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own projects" ON projects
  FOR DELETE USING (auth.uid() = user_id);

-- Documents
CREATE POLICY "Users can manage own documents" ON documents
  FOR ALL USING (auth.uid() = user_id);

-- Document versions
CREATE POLICY "Users can view own document versions" ON document_versions
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM documents d 
      WHERE d.id = document_versions.document_id 
      AND d.user_id = auth.uid()
    )
  );

-- AI generations
CREATE POLICY "Users can view own AI generations" ON ai_generations
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can create own AI generations" ON ai_generations
  FOR INSERT WITH CHECK (auth.uid() = user_id);
```

## Phase 5: Nuxt Configuration

Update `nuxt.config.ts`:

```typescript
export default defineNuxtConfig({
  modules: [
    '@nuxtjs/supabase',
    '@nuxtjs/tailwindcss',
    'shadcn-nuxt',
    '@pinia/nuxt',
    '@vueuse/nuxt',
    '@nuxt/image', // Add image optimization
  ],
  
  // Supabase configuration
  supabase: {
    redirectOptions: {
      login: '/auth/login',
      callback: '/auth/confirm',
      exclude: ['/', '/about', '/features'], // Public pages
    },
    clientOptions: {
      auth: {
        flowType: 'pkce',
        autoRefreshToken: true,
        detectSessionInUrl: true,
        persistSession: true,
      },
    },
  },
  
  // Shadcn configuration
  shadcn: {
    prefix: '', // No prefix for components
    componentDir: './components/ui'
  },
  
  // Runtime config
  runtimeConfig: {
    // Private keys (server-only)
    geminiApiKey: process.env.GEMINI_API_KEY,
    piapiKey: process.env.PIAPI_KEY,
    supabaseServiceKey: process.env.SUPABASE_SERVICE_KEY,
    
    // Public keys (available to client)
    public: {
      supabaseUrl: process.env.SUPABASE_URL,
      supabaseAnonKey: process.env.SUPABASE_ANON_KEY,
    }
  },
  
  // Nitro (server) configuration
  nitro: {
    // Pre-render static pages
    prerender: {
      crawlLinks: true,
      routes: ['/', '/features', '/pricing']
    },
    // Compress assets
    compressPublicAssets: true,
    // Optimize cold starts
    minify: true,
  },
  
  // Vite optimizations
  vite: {
    // Optimize dependencies
    optimizeDeps: {
      include: ['@tiptap/vue-3', '@tiptap/starter-kit']
    },
    // Build optimizations
    build: {
      rollupOptions: {
        output: {
          // Manual chunks for better caching
          manualChunks: {
            'tiptap': ['@tiptap/vue-3', '@tiptap/starter-kit', '@tiptap/pm'],
            'ui': ['radix-vue', 'class-variance-authority', 'clsx', 'tailwind-merge'],
          }
        }
      }
    }
  },
  
  // Image optimization
  image: {
    quality: 80,
    formats: ['webp', 'avif', 'jpeg'],
    screens: {
      xs: 320,
      sm: 640,
      md: 768,
      lg: 1024,
      xl: 1280,
      xxl: 1536,
    },
  },
  
  // CSS
  css: ['~/assets/css/main.css'],
  
  // Auto-imports
  imports: {
    dirs: ['stores', 'composables', 'utils']
  },
  
  // TypeScript
  typescript: {
    strict: true,
    typeCheck: true,
  },
  
  // Development
  devtools: { enabled: true }
})
```

## Phase 6: Implementation Architecture

### Server Routes (for Database Operations)

Create `server/api/documents/[id].get.ts`:
```typescript
import { serverSupabaseClient, serverSupabaseUser } from '#supabase/server'

export default defineEventHandler(async (event) => {
  const id = getRouterParam(event, 'id')
  const user = await serverSupabaseUser(event)
  
  if (!user) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Unauthorized'
    })
  }
  
  const client = await serverSupabaseClient(event)
  
  const { data, error } = await client
    .from('documents')
    .select('*')
    .eq('id', id)
    .eq('user_id', user.id)
    .single()
    
  if (error) {
    throw createError({
      statusCode: 404,
      statusMessage: 'Document not found'
    })
  }
  
  return data
})
```

Create `server/api/documents/index.post.ts`:
```typescript
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const user = await serverSupabaseUser(event)
  
  if (!user) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Unauthorized'
    })
  }
  
  const client = await serverSupabaseClient(event)
  
  // Extract plain text from Tiptap content
  const plainText = extractTextFromTiptap(body.content)
  
  const { data, error } = await client
    .from('documents')
    .insert({
      ...body,
      user_id: user.id,
      plain_text: plainText,
      word_count: plainText.split(/\s+/).length
    })
    .select()
    .single()
    
  if (error) throw error
  
  // Queue embedding generation
  await $fetch('/api/ai/embeddings', {
    method: 'POST',
    body: { documentId: data.id, text: plainText }
  })
  
  return data
})
```

### Edge Functions (for AI Operations)

Create `supabase/functions/generate-embedding/index.ts`:
```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { GoogleGenerativeAI } from 'https://esm.sh/@google/generative-ai'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const { documentId, text } = await req.json()
    
    // Initialize Supabase client
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    )
    
    // Generate embedding with Gemini
    const genAI = new GoogleGenerativeAI(Deno.env.get('GEMINI_API_KEY'))
    const model = genAI.getGenerativeModel({ model: "text-embedding-004" })
    
    const result = await model.embedContent(text)
    const embedding = result.embedding.values
    
    // Update document with embedding
    const { error } = await supabaseClient
      .from('documents')
      .update({ embedding })
      .eq('id', documentId)
      
    if (error) throw error
    
    return new Response(
      JSON.stringify({ success: true }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    )
  }
})
```

### AI Integration Services

Create `server/api/ai/generate.post.ts` (Gemini):
```typescript
import { GoogleGenerativeAI } from '@google/generative-ai'

export default defineEventHandler(async (event) => {
  const { prompt, type = 'text', context } = await readBody(event)
  const config = useRuntimeConfig()
  
  const genAI = new GoogleGenerativeAI(config.geminiApiKey)
  
  let model
  switch(type) {
    case 'text':
      model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })
      break
    case 'image':
      model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash-exp' })
      break
    case 'code':
      model = genAI.getGenerativeModel({ model: 'gemini-1.5-pro' })
      break
    default:
      model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })
  }
  
  // Build enhanced prompt with context
  const enhancedPrompt = context 
    ? `Context: ${context}\n\nRequest: ${prompt}`
    : prompt
  
  const result = await model.generateContent(enhancedPrompt)
  const response = await result.response
  
  // Track usage
  await trackAIUsage(event, {
    model: model.model,
    prompt,
    response: response.text(),
    tokens: response.usageMetadata?.totalTokenCount || 0
  })
  
  return { 
    content: response.text(),
    model: model.model,
    tokens: response.usageMetadata
  }
})
```

Create `server/api/ai/piapi/[service].post.ts` (Future PiAPI):
```typescript
// Ready for future PiAPI integration
export default defineEventHandler(async (event) => {
  const service = getRouterParam(event, 'service') // midjourney, dream-machine, etc.
  const { prompt, options = {} } = await readBody(event)
  const config = useRuntimeConfig()
  
  if (!config.piapiKey) {
    throw createError({
      statusCode: 501,
      statusMessage: 'PiAPI integration not configured'
    })
  }
  
  const endpoints = {
    'midjourney': 'https://api.piapi.ai/midjourney/imagine',
    'dream-machine': 'https://api.piapi.ai/dream-machine/generate',
    'faceswap': 'https://api.piapi.ai/faceswap/swap',
    'music': 'https://api.piapi.ai/ace-step/generate'
  }
  
  const response = await $fetch(endpoints[service], {
    method: 'POST',
    headers: {
      'X-API-Key': config.piapiKey,
      'Content-Type': 'application/json'
    },
    body: {
      prompt,
      ...options
    }
  })
  
  return response
})
```

## Phase 7: Components & Composables

### Create Composables

Create `composables/useAI.ts`:
```typescript
export const useAI = () => {
  const generateText = async (prompt: string, context?: string) => {
    return await $fetch('/api/ai/generate', {
      method: 'POST',
      body: { prompt, type: 'text', context }
    })
  }
  
  const generateImage = async (prompt: string) => {
    // Start with Gemini, upgrade to PiAPI Midjourney later
    return await $fetch('/api/ai/generate', {
      method: 'POST',
      body: { prompt, type: 'image' }
    })
  }
  
  const searchSimilar = async (query: string, projectId?: number) => {
    return await $fetch('/api/search/hybrid', {
      method: 'POST',
      body: { query, projectId }
    })
  }
  
  return {
    generateText,
    generateImage,
    searchSimilar
  }
}
```

### Initialize Shadcn UI

```bash
# Initialize shadcn-vue
npx shadcn-vue@latest init

# Add components as needed
npx shadcn-vue@latest add button
npx shadcn-vue@latest add input
npx shadcn-vue@latest add card
npx shadcn-vue@latest add dialog
npx shadcn-vue@latest add dropdown-menu
npx shadcn-vue@latest add toast
```

## Phase 8: Development Scripts

Update `package.json`:

```json
{
  "scripts": {
    "dev": "nuxt dev",
    "build": "nuxt build",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare",
    
    "db:start": "supabase start",
    "db:stop": "supabase stop",
    "db:reset": "supabase db reset",
    "db:migrate": "supabase db push",
    "db:types": "supabase gen types typescript --local > types/supabase.ts",
    "db:seed": "tsx prisma/seed.ts",
    
    "edge:serve": "supabase functions serve",
    "edge:deploy": "supabase functions deploy",
    
    "lint": "eslint .",
    "typecheck": "nuxt typecheck",
    
    "test": "vitest",
    "test:e2e": "playwright test"
  }
}
```

## Phase 9: Production Checklist

### Performance Optimizations

1. **Database Performance**
   - ✅ HNSW index configured with optimal parameters
   - ✅ Connection pooling enabled in Supabase
   - ✅ Prepared statements for repeated queries
   - ✅ Database warm-up queries on startup

2. **Vector Search Optimization**
   ```sql
   -- Pre-warm the index
   SELECT pg_prewarm('documents_embedding_idx');
   
   -- Monitor index performance
   SELECT * FROM pg_stat_user_indexes WHERE indexrelname = 'documents_embedding_idx';
   ```

3. **Caching Strategy**
   - Use Nuxt's built-in caching for API routes
   - Implement Redis for frequently accessed data
   - Cache embedding results for common queries

4. **Bundle Optimization**
   - Tree-shake unused Tiptap extensions
   - Lazy load heavy components
   - Use dynamic imports for AI features

### Security Considerations

1. **API Security**
   - Rate limiting on AI endpoints
   - Token validation for all protected routes
   - Sanitize Tiptap content before storage

2. **Cost Management**
   - Monitor Gemini API usage
   - Implement usage quotas per user
   - Cache AI responses when appropriate

### Deployment

```bash
# Build for production
npm run build

# Environment variables for production
NUXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NUXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-key
GEMINI_API_KEY=your-gemini-key
```

## Future Enhancements

### PiAPI Integration Roadmap

When ready to expand beyond Gemini's free tier:

1. **Midjourney Integration** - High-quality image generation
2. **Dream Machine** - Video generation from text/images
3. **Ace-step** - Music generation
4. **FaceSwap** - Advanced image manipulation

The infrastructure is already prepared for these integrations through the `/api/ai/piapi/[service]` endpoint structure.

### Additional Optimizations

1. **Streaming Responses** - Implement SSE for real-time AI responses
2. **Background Jobs** - Use Supabase Edge Functions for async processing
3. **Multi-modal Search** - Combine text and image embeddings
4. **Collaborative Features** - Real-time collaboration using Supabase Realtime

## Resources

- [Nuxt 3 Documentation](https://nuxt.com)
- [Supabase Documentation](https://supabase.com/docs)
- [pgvector Documentation](https://github.com/pgvector/pgvector)
- [Tiptap Documentation](https://tiptap.dev)
- [Shadcn-vue Documentation](https://www.shadcn-vue.com)
- [Google AI Studio](https://aistudio.google.com) - Get Gemini API key
- [PiAPI Documentation](https://piapi.ai/docs) - Future AI expansions

---

This optimized setup provides a production-ready foundation that scales from MVP to enterprise, with smart defaults and performance optimizations built in from the start.